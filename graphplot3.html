<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Canvas Function Grapher</title>
<style>
/* (Your original CSS unchanged) */
:root {
  --bg: #0f172a; --panel: #111827; --panel-2: #1f2937; --fg: #e5e7eb; --muted: #9ca3af;
  --accent: #22d3ee; --grid: #374151; --axis: #9ca3af; --plot: #7c3aed;
  --btn: #334155; --btn-hover: #475569; --danger: #ef4444; --ok: #10b981;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font: 14px/1.4 system-ui; }
.app { display: grid; grid-template-columns: 360px 1fr; min-height: 100svh; }
.sidebar { padding: 16px; background: var(--panel); border-right: 1px solid #0b1220; overflow: auto; }
.row { display: flex; gap: 8px; align-items: center; }
.row + .row { margin-top: 10px; }
label { color: var(--muted); font-size: 12px; }
input[type="text"] {
  width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #1f2937;
  background: var(--panel-2); color: var(--fg); outline: none;
}
select { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid #1f2937; background: var(--panel-2); color: var(--fg); }
.kbd { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; margin-top: 8px; }
button.k { padding: 8px 6px; border-radius: 10px; background: var(--btn); color: var(--fg); border: 1px solid #1f2937; cursor: pointer; user-select: none; }
button.k:hover { background: var(--btn-hover); }
button.primary { background: var(--accent); color: #0b1220; border: 1px solid #0ea5b6; }
button.danger { background: var(--danger); color: white; border-color: #b91c1c; }
small.help { color: var(--muted); display: block; margin-top: 6px; }
.canvas-wrap { position: relative; background: #020617; }
canvas { display: block; width: 100%; height: 100%; }
.toolbar { position: absolute; right: 12px; top: 12px; display: flex; gap: 8px; }
.pill { background: #0b1220cc; border: 1px solid #172036; padding: 6px 10px; border-radius: 999px; color: var(--fg); }
.badge { background: #0b1220; padding: 2px 8px; border-radius: 999px; color: var(--muted); border: 1px solid #18223a; }
.legend { position: absolute; left: 12px; top: 12px; display: flex; gap: 10px; align-items: center; }
.swatch { width: 12px; height: 12px; background: var(--plot); border-radius: 3px; border: 1px solid #6d28d9; }
.footer { padding: 8px 12px; color: var(--muted); background: #0b1220; border-top: 1px solid #0b1220; }
.split { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.err { color: #fecaca; background: #7f1d1d; padding: 6px 8px; border: 1px solid #991b1b; border-radius: 8px; margin-top: 8px; display: none; }
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="row">
      <div style="width:100%">
        <label for="expr">Equation:</label>
        <input id="expr" type="text" placeholder="e.g., sin(x) or x^2+y^2=1" value="sin(x)" />
        <small class="help">For implicit: use x and y with = (e.g., <code>x^2+y^2=1</code>)</small>
        <div id="err" class="err"></div>
      </div>
    </div>
    <div class="row">
      <div style="width:100%">
        <label>Math keypad</label>
        <div class="kbd" id="keypad"></div>
      </div>
    </div>
    <div class="row split">
      <div>
        <label for="examples">Examples</label>
        <select id="examples">
          <option value="">— choose —</option>
          <option>sin(x)</option>
          <option>x^2+y^2=1</option>
          <option>x*y=1</option>
        </select>
      </div>
      <div>
        <label for="resolution">Quality (samples)</label>
        <input id="resolution" type="range" min="300" max="3000" value="1200" />
        <small class="help"><span id="samplesLabel">1200</span> samples per plot</small>
      </div>
    </div>
    <div class="row">
      <button id="plotBtn" class="k primary">Plot (Enter)</button>
      <button id="clearBtn" class="k">Clear</button>
      <button id="resetBtn" class="k">Reset View</button>
    </div>
    <div class="row" style="margin-top:14px">
      <small class="help">Tip: Scroll to zoom. Drag to pan. Double-click to center.</small>
    </div>
  </aside>

  <!-- Canvas -->
  <main class="canvas-wrap" id="canvasWrap">
    <canvas id="cv"></canvas>
    <div class="legend">
      <span class="swatch"></span>
      <span class="badge" id="legendExpr">y = sin(x)</span>
    </div>
    <div class="toolbar">
      <span class="pill" id="scaleInfo">1 unit ≈ 50 px</span>
      <span class="pill" id="cursorInfo">x: –, y: –</span>
    </div>
    <div class="footer">Canvas Grapher • Supports explicit & implicit equations</div>
  </main>
</div>

<script>
/* === Original keypad setup === */
const keypadLayout = [
  'x','y','+','-','*','/','^','(',')',
  'sin(','cos(','tan(','sqrt(','abs(', 'ln(','log10(','exp(','π','e'
];
const keypad = document.getElementById('keypad');
const exprInput = document.getElementById('expr');
const legendExpr = document.getElementById('legendExpr');
const errBox = document.getElementById('err');

function insertAtCursor(text, cursorOffset = 0) {
  const el = exprInput;
  const start = el.selectionStart ?? el.value.length;
  const end = el.selectionEnd ?? el.value.length;
  const before = el.value.slice(0, start);
  const after = el.value.slice(end);
  el.value = before + text + after;
  const newPos = start + text.length + cursorOffset;
  el.focus();
  el.setSelectionRange(newPos, newPos);
  legendExpr.textContent = el.value;
}
keypadLayout.forEach(label => {
  const b = document.createElement('button');
  b.className = 'k'; b.textContent = label;
  b.addEventListener('click', () => insertAtCursor(label));
  keypad.appendChild(b);
});

document.getElementById('examples').addEventListener('change', (e) => {
  if (!e.target.value) return;
  exprInput.value = e.target.value;
  legendExpr.textContent = exprInput.value;
  plot();
});
document.getElementById('resolution').addEventListener('input', (e) => {
  document.getElementById('samplesLabel').textContent = e.target.value;
  plot();
});
document.getElementById('plotBtn').addEventListener('click', plot);
document.getElementById('clearBtn').addEventListener('click', () => { exprInput.value = ''; legendExpr.textContent = ''; plot(); });
document.getElementById('resetBtn').addEventListener('click', resetView);
exprInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); plot(); }});

/* === Canvas setup === */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const wrap = document.getElementById('canvasWrap');
const scaleInfo = document.getElementById('scaleInfo');
const cursorInfo = document.getElementById('cursorInfo');
let W = 0, H = 0; let ox = 0, oy = 0; let S = 50;

function fitCanvas() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  W = wrap.clientWidth; H = wrap.clientHeight - 24;
  cv.width = Math.floor(W * dpr);
  cv.height = Math.floor(H * dpr);
  cv.style.width = W + 'px'; cv.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
function resetView() { S = 50; ox = W/2; oy = H/2; plot(); }
window.addEventListener('resize', () => { fitCanvas(); resetView(); });

/* === Helpers === */
function niceStep() {
  const pxPerUnit = S; const targetPx = 80;
  const units = targetPx / pxPerUnit;
  const pow10 = Math.pow(10, Math.floor(Math.log10(units)));
  const base = units / pow10;
  let step = 1;
  if (base < 1.5) step = 1; else if (base < 3.5) step = 2; else if (base < 7.5) step = 5; else step = 10;
  return step * pow10;
}
function drawGrid() {
  ctx.clearRect(0,0,W,H);
  const step = niceStep();
  ctx.lineWidth = 1; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
  ctx.beginPath();
  let x0 = ox % (S*step);
  for (let x = x0; x <= W; x += S*step) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
  let y0 = oy % (S*step);
  for (let y = y0; y <= H; y += S*step) { ctx.moveTo(0, y); ctx.lineTo(W, y); }
  ctx.stroke();
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis');
  ctx.lineWidth = 1.5; ctx.beginPath();
  ctx.moveTo(0, oy); ctx.lineTo(W, oy); ctx.moveTo(ox, 0); ctx.lineTo(ox, H); ctx.stroke();
  ctx.fillStyle = '#9ca3af'; ctx.font = '12px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  for (let x = ox % (S*step); x <= W; x += S*step) {
    const xv = ((x - ox) / S).toFixed(2);
    ctx.fillText(xv, x, oy + 4);
  }
  ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
  for (let y = oy % (S*step); y <= H; y += S*step) {
    const yv = ((oy - y) / S).toFixed(2);
    if (Math.abs(y - oy) < 2) continue;
    ctx.fillText(yv, ox - 4, y);
  }
  scaleInfo.textContent = `1 unit ≈ ${S.toFixed(0)} px`;
}

/* === Normalization for shorthand === */
/*
function normalize(expr) {
  let e = expr;
  e = e.replace(/(\d)([a-zA-Z])/g, '$1*$2');       // number followed by variable
  e = e.replace(/([a-zA-Z])([a-zA-Z])/g, '$1*$2'); // variable followed by variable
  e = e.replace(/([a-zA-Z])\(/g, '$1*(');          // variable followed by (
  return e;
}

/* === Expression handling === */
/*
function sanitize(expr) {
  let e = normalize(expr.trim());
  e = e.replace(/\^/g, '**');
  const funcs = ['sin','cos','tan','asin','acos','atan','sqrt','abs','exp'];
  funcs.forEach(fn => { e = e.replace(new RegExp(`\\b${fn}\\s*\\(`,'g'), `Math.${fn}(`); });
  e = e.replace(/\bln\s*\(/g, 'Math.log(');
  e = e.replace(/\blog10\s*\(/g, '__LOG10__(');
  e = e.replace(/\bpow\s*\(/g, 'Math.pow(');
  e = e.replace(/π|\bpi\b/gi, 'Math.PI');
  e = e.replace(/(?<=^|[^0-9a-zA-Z_])e(?=$|[^0-9a-zA-Z_])/g, 'Math.E');
  e = e.replace(/\bX\b/g, 'x');
  return e;
}   */

/* === Normalization for shorthand === */
function normalize(expr) {
  let e = expr;
  e = e.replace(/(\d)([a-zA-Z(])/g, '$1*$2'); // number followed by variable or (
  e = e.replace(/([a-zA-Z)])(\d)/g, '$1*$2'); // variable or ) followed by number
  e = e.replace(/([)])([a-zA-Z(])/g, '$1*$2'); // ) followed by variable or (
  return e;
}

/* === Expression handling === */
function sanitize(expr) {
  let e = normalize(expr.trim());
  e = e.replace(/\^/g, '**'); // ^ → ** for power

  // Replace math functions with Math equivalents
  const funcs = ['sin','cos','tan','asin','acos','atan','sqrt','abs','exp'];
  funcs.forEach(fn => {
    e = e.replace(new RegExp(`\\b${fn}\\s*\\(`,'g'), `Math.${fn}(`);
  });

  // Special replacements
  e = e.replace(/\bln\s*\(/g, 'Math.log(');
  e = e.replace(/\blog10\s*\(/g, 'Math.log10('); // custom later if needed
  e = e.replace(/\bpow\s*\(/g, 'Math.pow(');

  // Constants
  e = e.replace(/π|\bpi\b/gi, 'Math.PI');
  e = e.replace(/(?<=^|[^0-9a-zA-Z_])e(?=$|[^0-9a-zA-Z_])/g, 'Math.E');

  return e;
}

// Add Math.log10 if missing
if (!Math.log10) {
  Math.log10 = function(x) {
    return Math.log(x) / Math.LN10;
  };
}



function compile(expr) {
  const e = sanitize(expr);
  const src = `"use strict"; const __LOG10__=(v)=>Math.log(v)/Math.LN10; return (x)=>{return ${e};};`;
  const fn = new Function(src)();
  fn(0);
  return fn;
}

/* === NEW: compile implicit equation === */
function compileImplicit(left, right) {
  const L = sanitize(left);
  const R = sanitize(right);
  const src = `"use strict"; const __LOG10__=(v)=>Math.log(v)/Math.LN10; return (x,y)=>{return (${L})-(${R});};`;
  const fn = new Function(src)();
  fn(0,0);
  return fn;
}

/* === Plot === */
function plot() {
  drawGrid();
  const expr = exprInput.value.trim();
  legendExpr.textContent = expr;
  errBox.style.display = 'none';
  if (!expr) return;

  try {
    if (expr.includes('=') && /[xy]/i.test(expr)) {
      const [left, right] = expr.split('=');
      plotImplicit(left, right);
    } else {
      plotExplicit(expr);
    }
  } catch (e) {
    errBox.textContent = e.message;
    errBox.style.display = 'block';
  }
}

function plotExplicit(expr) {
  const f = compile(expr);
  const samples = +document.getElementById('resolution').value;
  const stepPx = Math.max(1, Math.floor(W / samples));
  ctx.beginPath();
  ctx.lineWidth = 2; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--plot');
  let penDown = false; let lastY = null;
  for (let px = 0; px <= W; px += stepPx) {
    const x = (px - ox) / S;
    let y = f(x);
    if (!isFinite(y)) { penDown = false; lastY = null; continue; }
    const py = oy - y * S;
    if (lastY !== null && Math.abs(py - lastY) > H) { penDown = false; lastY = null; continue; }
    if (!penDown) { ctx.moveTo(px, py); penDown = true; }
    else { ctx.lineTo(px, py); }
    lastY = py;
  }
  ctx.stroke();
}

/* === NEW: plot implicit equation === */
function plotImplicit(left, right) {
  const fn = compileImplicit(left, right);
  ctx.fillStyle = '#ef4444'; // red dots
  const step = 2; // px grid
  const tol = 0.02; // tolerance
  for (let px = 0; px < W; px += step) {
    for (let py = 0; py < H; py += step) {
      const x = (px - ox) / S;
      const y = (oy - py) / S;
      const val = fn(x,y);
      if (Math.abs(val) < tol) ctx.fillRect(px, py, 1, 1);
    }
  }
}

/* === Interactions === */
let dragging = false; let lastMX = 0, lastMY = 0;
cv.addEventListener('mousedown', (e) => { dragging = true; lastMX = e.offsetX; lastMY = e.offsetY; });
window.addEventListener('mouseup', () => dragging = false);
cv.addEventListener('mousemove', (e) => {
  if (dragging) { ox += (e.offsetX - lastMX); oy += (e.offsetY - lastMY); lastMX = e.offsetX; lastMY = e.offsetY; plot(); }
  const x = ((e.offsetX - ox) / S); const y = ((oy - e.offsetY) / S);
  cursorInfo.textContent = `x: ${x.toFixed(3)}, y: ${y.toFixed(3)}`;
});

/* Zoom with scroll */
cv.addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const mx = e.offsetX;
  const my = e.offsetY;
  const worldX = (mx - ox) / S;
  const worldY = (oy - my) / S;

  if (e.deltaY < 0) { // zoom in
    S *= zoomFactor;
  } else { // zoom out
    S /= zoomFactor;
  }

  // Adjust origin to keep mouse position stable
  ox = mx - worldX * S;
  oy = my + worldY * S;

  plot();
});

/* Double-click to recenter */
cv.addEventListener('dblclick', (e) => {
  ox = e.offsetX;
  oy = e.offsetY;
  plot();
});

/* Initial setup */
fitCanvas();
resetView();
</script>
</body>
</html>

